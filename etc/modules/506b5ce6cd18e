<?xml version="1.0" encoding="UTF-8"?>
<so_gist so_uri="?gist=%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D0%B8+%D0%B2+JavaScript/by=Nin+Jin" so_gist_name="Модули в JavaScript" so_gist_author="Nin Jin" so_gist_content="    Когда кода становится очень много, когда его пишут разные люди в разных концах света, встаёт вопрос о разбиении его на файлы. К сожалению (а может и к счастью) JS не имеет встроенных средств инклуда и уж тем более автолоада. Поэтому остро встаёт проблема организации исходников так, чтобы:&#10;&#10;    • Они грузились в правильном порядке и подключалось только то, что нужно.&#10;    • Не конфликтовали между собой.&#10;    • На продакшене всё грузились одним-двумя файлами, а не сотней.&#10;    • Не было проблем с отладкой во время разработки.&#10;&#10;    Давайте рассмотрим наиболее яркие решения этой проблемы...&#10;&#10;!!! Глобальный конфиг&#10;&#10;    Обычно эта техника велосипедится каждым разработчиком на свой лад. Где-нибудь  укромном месте заводится специальный файлик, где перечисляется все необходимые скрипты. Например:&#10;&#10;#   js/common.php&#10;    &lt;?php return array(&#10;        'libs/jquery.js',&#10;        'libs/jquery-cookie.js',&#10;    );&#10;&#10;#   js/main.php&#10;    &lt;?php return array(&#10;        include( 'common.php' ),&#10;        'app/main.js',&#10;    );&#10;&#10;    При разработке каждый такой скрипт подключается отдельным тегом &lt;script/&gt;, а при выкладке на продакшен, исходники сливаются в один файл.&#10;&#10;+   Плюсы&#10;    + Предельно простая реализация.&#10;    + Мы точно знаем что и в каком порядке грузится.&#10;    + Нет никаких ограничений на содержимое подключаемых файлов.&#10;    + Может работать с различными типами ресурсов (js, css, шаблоны).&#10;&#10;−   Минусы&#10;    − Сложно поддерживать эти списки в актуальном состоянии, что приводит к загрузке лишнего кода или наоборот недозагрузке необходимого, но редко используемого.&#10;    − Вынуждает регистрировать каждый файл, а при переносе или переименовывании файла искать его упоминания и изменять их. Это рутина, которую разработчики стараются избегать, что приводит к излишней группировке большого числа модулей в небольшом числе файлов, а также бардаку с их расположением.&#10;    − Нельзя просто скопировать пачку файлов из другого проекта – нужно поподключать их  нужные места.&#10;    − Требуется серверный сборщик на нужном языке.    &#10;&#10;!!! CJS&#10;&#10;    Подход [CommonJS\http://www.commonjs.org/specs/] предполагает объявление зависимостей в самих модулях и отсутствие захламления глобальной области видимости. Каждый модуль исполняется в своей песочнице, где есть несколько предопределённых модулей: exports, require, module.&#10;&#10;#   js/libs/jquery.cjs.js&#10;    // jQuery content&#10;    exports.jQuery= jQuery&#10;&#10;#   js/libs/jquery-cookie.cjs.js&#10;    var $= require( '../libs/jquery.cjs' ).jQuery&#10;    // jQuery-cookie content&#10;&#10;#   js/modules/user.cjs.js&#10;    var $= require( '../libs/jquery.cjs' ).jQuery&#10;    exports.User= function( ){&#10;        // User content&#10;    }&#10;&#10;#   js/app/main.cjs.js&#10;    var $= require( '../libs/jquery.cjs' ).jQuery&#10;    var User= require( '../modules/user.cjs' ).User&#10;    require( '../libs/jquery-cookie.cjs' )&#10;    alert( new User( $.cookie.get( 'session-id' ) ) )&#10;&#10;    Как видно, если подключается библиотека, не рассчитанная на подключение через CommonJS API, то её код приходится модифицировать. Заметьте, тут jQuery-cookie ничего не экспортирует, а патчит jQuery (от которого зависит), поэтому в приложении мы вызываем require, чтобы патчинг состоялся.&#10;&#10;+   Плюсы&#10;    + Не засоряется глобальная область видимости.&#10;    + Зависимости всегда грузятся до того, как они понадобятся.&#10;&#10;−   Минусы&#10;    − Прежде чем воспользоваться каким-либо модулем, его нужно сначала импортировать с помощью require. А когда он больше не используется – нужно не забыть и удалить соответствующий require. Это рутина и потенциальное место ошибок загрузки (лишней или недостающей).&#10;    − Чтобы воспользоваться модулями в консоли, их опять же нужно проимпортировать, что нивелирует основное преимущество консоли – быстрая отладка без лишних телодвижений.&#10;    − Необходимо вносить изменения в код библиотек, не совместимых с CommonJS.&#10;    − Скрипты должны исполняться в отдельных «песочницах», что усложняет отладку и даёт пенальти в производительности.&#10;    − Статический анализ кода для поиска зависимостей либо очень сложный, либо не надёжный.&#10;    − Не умеет подключать необходимые для скриптов стили и шаблоны.&#10;    − Много инфраструктурного кода (подключение моделей, задание их имён).&#10;&#10;±   Спорные моменты&#10;    ± В разных скриптах один и тот же модуль может называться по разному. Это приводит к путанице при разработке (тут одно имя, там другое и боже упаси перепутать) и усложнению рефакторинга (перенос кода между скриптами, переименовывание модуля). А если ввести соглашение «везде называть одинаково», то это будет ничем не лучше глобальных переменных (разумеется с использованием пространств имён, как например $.cookie), а только хуже (из-за рутины с импортами).&#10;    ± Удобно динамически синхронно подгружать скрипты. Но это приводит к тормозам: при разработке из-за большого числа модулей (загрузка которых идёт последовательно), а на продакшене из-за долгой загрузки по сети собранного пакета. &#10;&#10;!!! AMD&#10;&#10;    [Asynchronous Module Definition\https://github.com/amdjs/amdjs-api/wiki/AMD] не требует изоляции модулей, но тем не менее поощряет её. Определение модуля заключается в вызове функции define или require с передачей им опционального списка зависимостей и коллбэк-функции, которая будет вызвана когда зависимости будут подгружены. В качестве зависимостей могут быть любые скрипты, в том числе даже и jsonp.&#10;&#10;#   js/libs/jquery.js&#10;    // jQuery content&#10;&#10;#   js/libs/jquery-cookie.js&#10;    // jQuery-cookie content&#10;&#10;#   js/modules/user.amd.js&#10;    define( [ &quot;../libs/jquery&quot; ], function( ){&#10;        // User content&#10;    })&#10;&#10;#   js/app/main.amd.js&#10;    require([ &quot;../modules/user.amd&quot;, &quot;../libs/jquery&quot;, &quot;../libs/jquery-cookie&quot; ],&#10;    function( User                                                         ){&#10;        alert( new User( $.cookie.get( 'session-id' ) ) )&#10;    })&#10;&#10;+   Плюсы&#10;    + Благодаря асинхронной архитектуре зависимости грузятся параллельно.&#10;    + Модуль инициализируется строго после загрузки зависимостей.&#10;&#10;−   Минусы&#10;    − Опять же, необходимость вручную следить за всеми зависимостями, со всеми вытекающими отсюда последствиями.&#10;    − Опять же, неудобства с консолью.&#10;    − Опять же, статический анализ зависимостей сложен или ненадёжен. Разве что используя тяжёлую артиллерию – один из серверных JS движков.&#10;    − Опять же, работает исключительно с JS и знать не знает про сопутствующие файлы.&#10;    − Очень громоздкое и вариативное определение модуля. Особенно это чувствуется, когда есть много зависимостей (параметры коллбэка сопоставляются с зависимостями по порядковому номеру).&#10;&#10;±   Спорные моменты&#10;    ± Опять же, возможность локального переименовывания модуля – фича скорее вредная, чем полезная.&#10;&#10;!!! JAM&#10;&#10;    Javascript Autoloadable Modules – конвенция в рамках архитектуры [PMS\https://github.com/nin-jin/pms/] (Package/Module/Source), идея которой заключается в том, чтобы организовывать исходники следующим образом:&#10;    • Все файлы (не только скрипты, но и сопутствующие им стили, картнки, шаблоны и прочее) лежат на одном уровне иерархии и объединены в модули. &#10;    • Имена файлов произвольные. Файлов одного типа может быть произвольное количество.&#10;    • Модули объединены в пакеты. На продакшене, все модули грузятся объединёнными попакетно. При разработке все файлы подключаются по отдельности.&#10;    • Зависимости между модулями определяются статическим анализом содержащихся в них исходников, основываясь на расширении файлов.&#10;    • Все файлы подключаемого модуля входят в сборку пакета, даже если сам модуль из другого пакета.&#10;&#10;    Конкретно JAM соглашение заключается в следующем:&#10;    • Все модули регистрируются глобально используя символ доллара в начале, при этом имя пакета выступает в качестве пространства имён для модулей.&#10;    • Если в jam-файле встречается комбинация вида «$foo.bar», то считается, что его модуль зависит от модуля «bar» в пакете «foo».&#10;    • JAM-файлы должны иметь расширение «jam.js», чтобы не путать их с обычными JS-файлами, зависимости внутри которых не анализируются.&#10;    • Все модули пакета зависят от главного модуля пакета, который имеет то же имя, что и сам пакет.&#10;&#10;    Правила достаточно тривиальны. Проще понять их на простом примере:&#10;    &#10;#   jq/jq/jq.js&#10;    // jQuery content&#10;&#10;#   jq/jq/jq_ns.jam.js&#10;    this.$jq= jQuery&#10;&#10;#   jq/cookie/jq_cookie.js&#10;    // jQuery-cookie content&#10;&#10;#   myApp/myApp/myApp.jam.js&#10;    this.$myApp= {}&#10;&#10;#   myApp/User/myApp_User.jam.js&#10;    $myApp.User= function(){&#10;        // User content&#10;    }&#10;&#10;#   myApp/startup/myApp_startup.jam.js&#10;    alert( new $myApp.User( $jq.cookie.get( 'session-id' ) ) )&#10;&#10;    Дополнительные зависимости, которые автоматика (пока;) не в состоянии распознать, можно указывать в отдельном файле в формате, meta-tree:&#10;&#10;#   jq/cookie-plus/jquery_cookie-plus.js&#10;    // jQuery-cookie-plus content&#10;&#10;#   jq/cookie-plus/jquery_cookie-plus.meta.tree&#10;    include module= jq/cookie&#10;&#10;+   Плюсы&#10;    + Нет никаких ограничений на содержимое подключаемых js-файлов (только на jam).&#10;    + Зависимости в основном определяются автоматически. Дополнительно вручную задаются в отдельном файле для модуля целиком, а не для каждого файла по отдельности.&#10;    + Отсутствие какой-либо рантайм библиотеки (все зависимости подключаются статически).&#10;    + При разработке все файлы подключаются отдельно и грузятся параллельно – это быстро и удобно в отладке.&#10;    + В ссылки на файлы добавлется метка времени модификации, что избавляет от необходимости чистить кэш браузера и от лишних http-запросов.&#10;    + Системное решение. Вместе со скриптами подгружаются и стили, и шаблоны. А вместе с шаблонами, необходимые скрипты и стили (в том числе скрипты, стили и подшаблоны из других модулей).&#10;    + Единое именование модулей везде и отсутствие необходимости каждый файл где-либо прописывать позволяет легко рефакторить код и в том числе переносить между проектами.&#10;&#10;−   Минусы&#10;    − Теоретически возможно неправильное распознание зависимости (например, в закоментированном коде или строковой константе), но на практике, зная правила их поиска, допустить эти ошибки сложно.&#10;    − Нельзя напрямую использовать сторонний код, апи которого использует знак доллара. В примере выше, эта проблема обходится созданием алиаса, удовлетворяющим принципам JAM.&#10;&#10;±   Спорные моменты&#10;    ± Требуется серверный сборщик. Впрочем, запускается он как утилита, которая формирует все необходимые файлы в модуле «-mix», что совсем не страшно.&#10;    ± Все модули доступны глобально, что потенциально конфликтноопасно. Однако, для встраивания на сторонние сайты, собирается специальная изолированная версия – «library.js».&#10;&#10;!!! Попробуйте PMS&#10;&#10;    Чтобы было легко поиграться, я написал простенький тестовый [пример\https://github.com/nin-jin/PMS-demo]. Скрипт «index.php» сначала запускает компиляцию пакета «pms-demo», а потом выдаёт браузеру статическую хтмл-ку, внутри которой можно обнаружить закоментированные другие варианты подключения: пофайлово, скомпилированно по типам, скомпилировано в 1 файл. &#10;"/>
